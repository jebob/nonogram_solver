use crate::CellState::{Black, Unknown, White};
use std::fs;

#[derive(Debug)]
enum BadSolveError {
    Err,
}

#[derive(Copy, Clone, Debug, PartialEq)]
enum CellState {
    Black,
    White,
    Unknown,
}

fn parse_file(target: &str) -> (Vec<Vec<usize>>, Vec<Vec<usize>>) {
    // Parse saved puzzle hints
    // Generated by copy-pasting the grid from https://www.brainbashers.com/nonogrids.asp
    // and removing trailing copyright stuff
    let mut contents = fs::read_to_string(target).unwrap();
    contents = contents.trim_end().trim_start().to_string();
    let (col_text, row_text) = contents.split_once(" ").unwrap();
    // Part 1: columns
    // Each column is a collection of numbers, joined by newlines, joined by tabs
    let columns: Vec<Vec<usize>> = col_text
        .split("\t")
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();
    // Part 2: rows
    // Each row is a collection of numbers, joined by mixed whitespace, joined by \n+space
    let rows: Vec<Vec<usize>> = row_text
        .split("\n")
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();

    // Part 3: validation
    if columns.len() != rows.len() {
        panic!("Non-square puzzle!")
    }
    // Maybe these trigger if there is a clue of "0", but this is an odd clue
    if columns.iter().any(|group| group.iter().any(|el| *el == 0)) {
        panic!("Bad parse in columns")
    }
    if rows.iter().any(|group| group.iter().any(|el| *el == 0)) {
        panic!("Bad parse in rows")
    }

    return (rows, columns);
}

fn state_compatible(a: &Vec<CellState>, b: &Vec<CellState>) -> bool {
    // Compare two vectors a & b, returning true if they are compatible
    // If different lengths, ignore the excess
    for (ela, elb) in a.iter().zip(b) {
        if (*ela == Black) & (*elb == White) | (*ela == White) & (*elb == Black) {
            return false;
        }
    }
    true
}

fn solve_group(hint: Vec<usize>, state: Vec<CellState>) -> Result<Vec<CellState>, BadSolveError> {
    // Try to solve this group, using the known state and the hint
    if hint.len() == 0 {
        // No Blacks, so must be all White
        return if state.iter().any(|el| *el == Black) {
            // But there's a Black!
            Err(BadSolveError::Err)
        } else {
            Ok(vec![White; state.len()])
        };
    }

    // Try to fit the first hint in
    let block_size = *hint.get(0).unwrap();
    let mut any_solution = false;
    let mut maybe_white = vec![false; state.len()];
    let mut maybe_black = vec![false; state.len()];

    for offset in 0..state.len() {
        let mut try_state = vec![White; offset];
        try_state.append(&mut vec![Black; block_size]);
        if try_state.len() > state.len() {
            // too large offset
            break;
        }
        try_state.push(White); // Must be followed by White or end of group
        if state_compatible(&state, &try_state) {
            // This hint is ok, but what about the other hints?
            // todo Need to recurse here
            // Found a valid solution! record it
            any_solution = true;
            for i in 0..state.len() {
                match i {
                    i if i < offset => {
                        maybe_white[i] = true;
                    }
                    i if i < offset + block_size => {
                        maybe_black[i] = true;
                    }
                    _ => {
                        // todo replace this with recursion result
                        maybe_white[i] = true;
                    }
                }
            }
            /*
            if offset > 0 {
                for i in 0..(offset - 1) {
                    maybe_white[i] = true;
                }
            }
            for i in offset..(offset + block_size) {
                maybe_black[i] = true;
            }
            for i in (offset + block_size)..(maybe_white.len()) {
                maybe_white[i] = true;
            }
             */
        }
    }
    if !any_solution {
        // Couldn't find any solution, abort.
        return Err(BadSolveError::Err);
    }

    // Construct new solved state
    fn combine(
        existing_maybe_white_maybe_black: ((&CellState, bool), bool),
    ) -> Result<CellState, BadSolveError> {
        let ((existing, maybe_white), maybe_black) = existing_maybe_white_maybe_black;
        match existing {
            CellState::Unknown => {
                if maybe_white & maybe_black {
                    Ok(Unknown)
                } else if maybe_black {
                    Ok(Black)
                } else if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            White => {
                if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            Black => {
                if maybe_black {
                    Ok(Black)
                } else {
                    Err(BadSolveError::Err)
                }
            }
        }
    }
    let new_state: Result<Vec<CellState>, BadSolveError> = state
        .iter()
        .zip(maybe_white)
        .zip(maybe_black)
        .map(combine)
        .collect();
    new_state
}

fn group_is_solved(hint: Vec<usize>, state: Vec<CellState>) -> Result<bool, BadSolveError> {
    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::CellState::{Unknown, White};

    #[test]
    fn test_state_compatible() {
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, White]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, Black]
        ));
        assert!(!state_compatible(
            &vec![White, Unknown],
            &vec![Black, Black]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![White, Black, White]
        ));
    }

    #[test]
    fn solve_group_zero_hints() {
        // Zero hints mean all White
        assert_eq!(solve_group(vec![], vec![Unknown]).unwrap(), [White]);
        assert_eq!(
            solve_group(vec![], vec![Unknown, White]).unwrap(),
            [White, White]
        );
        assert!(solve_group(vec![], vec![Unknown, Black]).is_err());
    }

    #[test]
    fn solve_group_one() {
        assert_eq!(solve_group(vec![1], vec![Unknown]).unwrap(), [Black]);
        assert_eq!(
            solve_group(vec![2], vec![Black, Black]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_group(vec![1], vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Unknown, Unknown]
        );
        assert_eq!(
            solve_group(vec![1], vec![Unknown, Unknown]).unwrap(),
            [Unknown, Unknown]
        );
        assert_eq!(
            solve_group(vec![2], vec![Unknown, Unknown]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_group(vec![2], vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Black, Unknown]
        );
        assert!(solve_group(vec![2], vec![Unknown, White, Unknown]).is_err());
        assert!(solve_group(vec![20], vec![Unknown, Unknown]).is_err());
    }

    #[test]
    fn solve_group_two() {

    }
}

fn solve_inner(rows: Vec<Vec<usize>>, cols: Vec<Vec<usize>>, known_state: Vec<Vec<CellState>>) {
    // Deductive phase
    // While successfully solving
    // solve rows
    // solve columns

    // Check if fully solved, if so return.

    // Not possible to deduce further
    // Brute force
    // pick an unknown cell as white and solve_inner
    // if that works, return
    // if that doesn't work, try the alternative
    // if that works, return
    // if that doesn't work, abort
}

fn solve(rows: Vec<Vec<usize>>, cols: Vec<Vec<usize>>) {
    // Build initial state
    let state = vec![vec![CellState::Unknown; cols.len()]; rows.len()];

    solve_inner(rows, cols, state)
}

fn main() {
    let (rows, cols) = parse_file("Examples/Easy1.txt");
    println!("{:?}", rows);
    println!("{:?}", cols);
    solve(rows, cols);
    let (rows, cols) = parse_file("Examples/Hard1.txt");
    println!("{:?}", rows);
    println!("{:?}", cols);
    solve(rows, cols);
}
