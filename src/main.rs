use crate::CellState::{Black, Unknown, White};
use std::fs;

#[derive(Debug)]
enum BadSolveError {
    Err,
}

#[derive(Copy, Clone, Debug, PartialEq)]
enum CellState {
    Black,
    White,
    Unknown,
}

fn transpose<T>(v: Vec<Vec<T>>) -> Vec<Vec<T>>
where
    T: Clone,
{
    assert!(!v.is_empty());
    (0..v[0].len())
        .map(|i| v.iter().map(|inner| inner[i].clone()).collect::<Vec<T>>())
        .collect()
}

fn parse_file(target: &str) -> (Vec<Vec<usize>>, Vec<Vec<usize>>) {
    // Parse saved puzzle hints
    // Generated by copy-pasting the grid from https://www.brainbashers.com/nonogrids.asp
    // and removing trailing copyright stuff
    let mut contents = fs::read_to_string(target).unwrap();
    contents = contents.trim_end().trim_start().to_string();
    let (col_text, row_text) = contents.split_once(" ").unwrap();
    // Part 1: columns
    // Each column is a collection of numbers, joined by newlines, joined by tabs
    let columns: Vec<Vec<usize>> = col_text
        .split("\t")
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();
    // Part 2: rows
    // Each row is a collection of numbers, joined by mixed whitespace, joined by \n+space
    let rows: Vec<Vec<usize>> = row_text
        .split("\n")
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();

    // Part 3: validation
    if columns.len() != rows.len() {
        panic!("Non-square puzzle!")
    }
    // Maybe these trigger if there is a clue of "0", but this is an odd clue
    if columns.iter().any(|group| group.iter().any(|el| *el == 0)) {
        panic!("Bad parse in columns")
    }
    if rows.iter().any(|group| group.iter().any(|el| *el == 0)) {
        panic!("Bad parse in rows")
    }

    return (rows, columns);
}

fn state_compatible(a: &[CellState], b: &[CellState]) -> bool {
    // Compare two vectors a & b, returning true if they are compatible
    // If different lengths, ignore the excess
    for (ela, elb) in a.iter().zip(b) {
        if (*ela == Black) & (*elb == White) | (*ela == White) & (*elb == Black) {
            return false;
        }
    }
    true
}

fn solve_group_(
    hint: &[usize],
    state: &[CellState],
) -> Result<(Vec<bool>, Vec<bool>), BadSolveError> {
    // Try to solve this group, using the known state and the hint
    // state (as given) is proven state
    // this function returns observed possibilities (whites, blacks)

    if hint.len() == 0 {
        // No Blacks, so must be all White
        return if state.iter().any(|el| *el == Black) {
            // But there's a Black!
            Err(BadSolveError::Err)
        } else {
            Ok((vec![true; state.len()], vec![false; state.len()]))
        };
    }

    // Try to fit the first hint in
    let block_size = *hint.get(0).unwrap();
    let mut any_solution = false;
    let mut maybe_white = vec![false; state.len()];
    let mut maybe_black = vec![false; state.len()];

    for offset in 0..state.len() {
        let mut try_state = vec![White; offset];
        try_state.append(&mut vec![Black; block_size]);
        if try_state.len() > state.len() {
            // too large offset
            break;
        }
        try_state.push(White); // Must be followed by White or end of group
        if state_compatible(&state, &try_state) {
            // This block is ok, but what about the other blocks?
            let reduced_hint = &hint[1..];
            let mut allocated = offset + block_size;
            if allocated < state.len() {
                // add a white block
                allocated += 1;
            }
            let reduced_state = &state[allocated..];
            let res = solve_group_(reduced_hint, reduced_state);
            if res.is_err() {
                continue;
            }
            let (remainder_white, remainder_black) = res.unwrap();

            // Found a valid set of solutions! record it
            any_solution = true;
            for i in 0..state.len() {
                match i {
                    _ if i < offset => {
                        maybe_white[i] = true;
                    }
                    _ if i < offset + block_size => {
                        maybe_black[i] = true;
                    }
                    _ if i == offset + block_size => {
                        maybe_white[i] = true;
                    }
                    _ => {
                        maybe_white[i] |= remainder_white[i - offset - block_size - 1];
                        maybe_black[i] |= remainder_black[i - offset - block_size - 1];
                    }
                }
            }
        }
    }
    if !any_solution {
        // Couldn't find any solution, abort.
        return Err(BadSolveError::Err);
    }

    Ok((maybe_white, maybe_black))
}

fn solve_group(hint: &[usize], state: &[CellState]) -> Result<Vec<CellState>, BadSolveError> {
    // Try to solve this group, using the known state and the hint

    // idea: add some simple criteria to check solvability.
    // Perhaps the full algorithm obviously has no solutions

    let (maybe_white, maybe_black) = solve_group_(&hint, &state)?;

    // Construct new solved state
    fn combine(
        existing_maybe_white_maybe_black: ((&CellState, bool), bool),
    ) -> Result<CellState, BadSolveError> {
        let ((existing, maybe_white), maybe_black) = existing_maybe_white_maybe_black;
        match existing {
            CellState::Unknown => {
                if maybe_white & maybe_black {
                    Ok(Unknown)
                } else if maybe_black {
                    Ok(Black)
                } else if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            White => {
                if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            Black => {
                if maybe_black {
                    Ok(Black)
                } else {
                    Err(BadSolveError::Err)
                }
            }
        }
    }
    let new_state: Result<Vec<CellState>, BadSolveError> = state
        .iter()
        .zip(maybe_white)
        .zip(maybe_black)
        .map(combine)
        .collect();
    new_state
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::CellState::{Unknown, White};

    #[test]
    fn test_state_compatible() {
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, White]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, Black]
        ));
        assert!(!state_compatible(
            &vec![White, Unknown],
            &vec![Black, Black]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![White, Black, White]
        ));
    }

    #[test]
    fn solve_group_zero_hints() {
        // Zero hints mean all White
        assert_eq!(solve_group(&vec![], &vec![Unknown]).unwrap(), [White]);
        assert_eq!(
            solve_group(&vec![], &vec![Unknown, White]).unwrap(),
            [White, White]
        );
        assert!(solve_group(&vec![], &vec![Unknown, Black]).is_err());
    }

    #[test]
    fn solve_group_one() {
        assert_eq!(solve_group(&vec![1], &vec![Unknown]).unwrap(), [Black]);
        assert_eq!(
            solve_group(&vec![2], &vec![Black, Black]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_group(&vec![1], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Unknown, Unknown]
        );
        assert_eq!(
            solve_group(&vec![1], &vec![Unknown, Unknown]).unwrap(),
            [Unknown, Unknown]
        );
        assert_eq!(
            solve_group(&vec![2], &vec![Unknown, Unknown]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_group(&vec![2], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Black, Unknown]
        );
        assert!(solve_group(&vec![2], &vec![Unknown, White, Unknown]).is_err());
        assert!(solve_group(&vec![20], &vec![Unknown, Unknown]).is_err());
    }

    #[test]
    fn solve_group_two() {
        assert!(solve_group(&vec![1, 1], &vec![Unknown, Unknown]).is_err());
        assert_eq!(
            solve_group(&vec![1, 1], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Black, White, Black]
        );
        assert_eq!(
            solve_group(&vec![1, 1], &vec![Unknown, Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Unknown, Unknown, Unknown]
        );
        assert_eq!(
            solve_group(&vec![1, 1], &vec![Unknown, Unknown, Black, Unknown]).unwrap(),
            [Black, White, Black, White]
        );
        assert_eq!(
            solve_group(&vec![1, 1], &vec![Unknown, Unknown, Black, Unknown, Black]).unwrap(),
            [White, White, Black, White, Black]
        );
    }
}

fn solve_inner(
    rows: Vec<Vec<usize>>,
    cols: Vec<Vec<usize>>,
    mut known_state: Vec<Vec<CellState>>,
) -> Result<Vec<Vec<CellState>>, BadSolveError> {
    // Deductive phase
    // While successfully solving
    // solve rows
    // solve columns
    let mut row_change = true;
    let mut col_change = true;
    while col_change {
        col_change = false;
        // solve each row
        for (hint, row_state) in rows.iter().zip(known_state.iter_mut()) {
            let new = solve_group(hint, row_state)?;
            if new != *row_state {
                row_change = true;
                *row_state = new;
            }
        }

        if row_change {
            row_change = false;
            known_state = transpose(known_state);
            // solve each col
            for (hint, col_state) in cols.iter().zip(known_state.iter_mut()) {
                let new = solve_group(hint, col_state)?;
                if new != *col_state {
                    col_change = true;
                    *col_state = new;
                }
            }
            known_state = transpose(known_state);
        }
    }

    // Check if fully solved, if so return.

    // Not possible to deduce further
    // Brute force
    // pick an unknown cell as white and solve_inner
    // if that works, return
    // if that doesn't work, try the alternative
    // if that works, return
    // if that doesn't work, abort
    Ok(known_state)
}

fn solve(
    rows: Vec<Vec<usize>>,
    cols: Vec<Vec<usize>>,
) -> Result<Vec<Vec<CellState>>, BadSolveError> {
    // Build initial state
    let state = vec![vec![CellState::Unknown; cols.len()]; rows.len()];

    solve_inner(rows, cols, state)
}

fn prettify(state: &Vec<Vec<CellState>>) -> String {
    fn disp(el: &CellState) -> &'static str {
        match el {
            Black => "X",
            White => " ",
            Unknown => "?",
        }
    }
    return state
        .iter()
        .map(|row| row.iter().map(disp).collect::<String>())
        .collect::<Vec<String>>()
        .join("\r\n");
}

fn main() {
    for file in [
        //"Examples/Easy1.txt",
        //"Examples/Easy2.txt",
        "Examples/Hard1.txt",
    ] {
        println!("Solving {}", file);
        let (rows, cols) = parse_file(file);
        let result = solve(rows, cols).unwrap();
        println!("{}", prettify(&result));
    }
}
