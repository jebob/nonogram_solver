// Nonogram puzzle solver
//     To solve a puzzle from [Brainbashers](https://www.brainbashers.com/nonogrids.asp)
// Copy/paste the grid into a text file
//     To solve a puzzle from [webpbn](https://webpbn.com)
// Go to https://webpbn.com/XMLpuz.cgi?id={puzzle_id} and save that xml as a file.
//
// Ideas for speeding up
// Note that 99% of runtime is in solve_group_
// I use two data structures, is this sensible?
// * two arrays (black & white) of bools to represent observed possibilities
// * an array of CellStates to represent deduced state
// solve_group_ considers all possibilities. This is slow.
// * Can I demonstrate unsolvability? e.g. hint (1), state [Unknown; 5]
//   * Simple case like this is easy, but a general & fast proof is tricky.
// * Can I use an 80:20 algorithm most of the time? This could be a speedup
// * Parallelize solve_group? Sadly this is only a x8 speedup.
// * Filter out unchanged rows & columns from solve_inner
//   * Maybe have an initial filtering so we start with a small set

use crate::CellState::{Black, Unknown, White};
use std::fs;
use std::fs::File;
use std::io::BufReader;
use xml::reader::{EventReader, XmlEvent};

extern crate xml;

#[derive(Debug)]
enum BadSolveError {
    Err,
}

#[derive(Copy, Clone, Debug, PartialEq)]
enum CellState {
    Black,
    White,
    Unknown,
}

fn transpose<T>(v: Vec<Vec<T>>) -> Vec<Vec<T>>
where
    T: Clone,
{
    assert!(!v.is_empty());
    (0..v[0].len())
        .map(|i| v.iter().map(|inner| inner[i].clone()).collect::<Vec<T>>())
        .collect()
}

fn parse_file(target: &str) -> (Vec<Vec<usize>>, Vec<Vec<usize>>) {
    let (rows, columns) = if target.ends_with(".xml") {
        parse_file_webbpn(target)
    } else {
        parse_file_brainbashers(target)
    };
    // Validation
    // Maybe these trigger if there is a clue of "0", but this is an odd clue
    if columns.iter().any(|line| line.iter().any(|el| *el == 0)) {
        panic!("Bad parse in columns\n{:?}\n{:?}", rows, columns)
    }
    if rows.iter().any(|line| line.iter().any(|el| *el == 0)) {
        panic!("Bad parse in rows\n{:?}\n{:?}", rows, columns)
    }
    if rows
        .iter()
        .map(|line| line.iter().sum::<usize>())
        .sum::<usize>()
        != columns
            .iter()
            .map(|line| line.iter().sum::<usize>())
            .sum::<usize>()
    {
        panic!("Rows and columns contain different total black cells.")
    }
    (rows, columns)
}

fn parse_file_brainbashers(target: &str) -> (Vec<Vec<usize>>, Vec<Vec<usize>>) {
    // Parse saved puzzle hints
    // Generated by copy-pasting the grid from https://www.brainbashers.com/nonogrids.asp
    // and removing trailing copyright stuff
    let mut contents = fs::read_to_string(target).unwrap();
    contents = contents.trim_end().trim_start().to_string();
    let (col_text, row_text) = contents.split_once(" ").unwrap();
    // Part 1: columns
    // Each column is a collection of numbers, joined by newlines, joined by tabs
    let columns: Vec<Vec<usize>> = col_text
        .split('\t')
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();
    // Part 2: rows
    // Each row is a collection of numbers, joined by mixed whitespace, joined by \n+space
    let rows: Vec<Vec<usize>> = row_text
        .split('\n')
        .map(|col| {
            col.split_whitespace()
                .map(|el| el.parse::<usize>().unwrap_or(0))
                .collect()
        })
        .collect();

    (rows, columns)
}

fn parse_file_webbpn(target: &str) -> (Vec<Vec<usize>>, Vec<Vec<usize>>) {
    let file = File::open(target).unwrap();
    let file = BufReader::new(file);

    let parser = EventReader::new(file);
    let mut is_rows = false;
    let mut rows: Vec<Vec<usize>> = vec![];
    let mut columns: Vec<Vec<usize>> = vec![];
    let mut line: Vec<usize> = vec![];
    for e in parser {
        match e {
            Ok(XmlEvent::StartElement { name, .. }) if name.to_string() == "line" => {
                line = vec![];
            }
            Ok(XmlEvent::EndElement { name }) if name.to_string() == "line" => {
                if is_rows {
                    rows.push(line.clone());
                } else {
                    columns.push(line.clone());
                }
            }
            Ok(XmlEvent::StartElement {
                name, attributes, ..
            }) if name.to_string() == "clues" => {
                for attr in attributes {
                    if (attr.name.to_string() == "type") & (attr.value == "rows") {
                        is_rows = true;
                    }
                }
            }
            Ok(XmlEvent::Characters(text)) => match text.parse() {
                Ok(val) => line.push(val),
                _ => {}
            },
            Err(e) => {
                println!("Error: {}", e);
                break;
            }
            _ => {}
        }
    }
    (rows, columns)
}

fn state_compatible(a: &[CellState], b: &[CellState]) -> bool {
    // Compare two vectors a & b, returning true if they are compatible
    // If different lengths, ignore the excess
    for (ela, elb) in a.iter().zip(b) {
        if (*ela == Black) & (*elb == White) | (*ela == White) & (*elb == Black) {
            return false;
        }
    }
    true
}

fn solve_line_(
    hint: &[usize],
    state: &[CellState],
) -> Result<(Vec<bool>, Vec<bool>), BadSolveError> {
    // Try to solve this line, using the known state and the hint
    // state (as given) is proven state
    // this function returns observed possibilities (whites, blacks)

    if hint.is_empty() {
        // No Blacks, so must be all White
        return if state.iter().any(|el| *el == Black) {
            // But there's a Black!
            Err(BadSolveError::Err)
        } else {
            Ok((vec![true; state.len()], vec![false; state.len()]))
        };
    }

    // Try to fit the first hint in
    let block_size = *hint.get(0).unwrap();
    let mut any_solution = false;
    let mut maybe_white = vec![false; state.len()];
    let mut maybe_black = vec![false; state.len()];

    for offset in 0..state.len() {
        let mut try_state = vec![White; offset];
        try_state.append(&mut vec![Black; block_size]);
        if try_state.len() > state.len() {
            // too large offset
            break;
        }
        try_state.push(White); // Must be followed by White or the line's end
        if state_compatible(state, &try_state) {
            // This block is ok, but what about the other blocks?
            let reduced_hint = &hint[1..];
            let mut allocated = offset + block_size;
            if allocated < state.len() {
                // add a white block
                allocated += 1;
            }
            let reduced_state = &state[allocated..];
            let res = solve_line_(reduced_hint, reduced_state);
            if res.is_err() {
                continue;
            }
            let (remainder_white, remainder_black) = res.unwrap();

            // Found a valid set of solutions! record it
            any_solution = true;
            for i in 0..state.len() {
                match i {
                    _ if i < offset => {
                        maybe_white[i] = true;
                    }
                    _ if i < offset + block_size => {
                        maybe_black[i] = true;
                    }
                    _ if i == offset + block_size => {
                        maybe_white[i] = true;
                    }
                    _ => {
                        maybe_white[i] |= remainder_white[i - offset - block_size - 1];
                        maybe_black[i] |= remainder_black[i - offset - block_size - 1];
                    }
                }
            }
        }
    }
    if !any_solution {
        // Couldn't find any solution, abort.
        return Err(BadSolveError::Err);
    }

    Ok((maybe_white, maybe_black))
}

fn solve_line(hint: &[usize], state: &[CellState]) -> Result<Vec<CellState>, BadSolveError> {
    // Try to solve this line, using the known state and the hint

    // idea: add some simple criteria to check solvability.
    // Perhaps the full algorithm obviously has no solutions

    let (maybe_white, maybe_black) = solve_line_(hint, state)?;

    // Construct new solved state
    fn combine(
        existing_maybe_white_maybe_black: ((&CellState, bool), bool),
    ) -> Result<CellState, BadSolveError> {
        let ((existing, maybe_white), maybe_black) = existing_maybe_white_maybe_black;
        match existing {
            CellState::Unknown => {
                if maybe_white & maybe_black {
                    Ok(Unknown)
                } else if maybe_black {
                    Ok(Black)
                } else if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            White => {
                if maybe_white {
                    Ok(White)
                } else {
                    Err(BadSolveError::Err)
                }
            }
            Black => {
                if maybe_black {
                    Ok(Black)
                } else {
                    Err(BadSolveError::Err)
                }
            }
        }
    }
    let new_state: Result<Vec<CellState>, BadSolveError> = state
        .iter()
        .zip(maybe_white)
        .zip(maybe_black)
        .map(combine)
        .collect();
    new_state
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::CellState::{Unknown, White};

    #[test]
    fn test_state_compatible() {
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, White]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![Unknown, Black]
        ));
        assert!(!state_compatible(
            &vec![White, Unknown],
            &vec![Black, Black]
        ));
        assert!(state_compatible(
            &vec![White, Unknown],
            &vec![White, Black, White]
        ));
    }

    #[test]
    fn solve_line_zero_hints() {
        // Zero hints mean all White
        assert_eq!(solve_line(&vec![], &vec![Unknown]).unwrap(), [White]);
        assert_eq!(
            solve_line(&vec![], &vec![Unknown, White]).unwrap(),
            [White, White]
        );
        assert!(solve_line(&vec![], &vec![Unknown, Black]).is_err());
    }

    #[test]
    fn solve_line_one() {
        assert_eq!(solve_line(&vec![1], &vec![Unknown]).unwrap(), [Black]);
        assert_eq!(
            solve_line(&vec![2], &vec![Black, Black]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_line(&vec![1], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Unknown, Unknown]
        );
        assert_eq!(
            solve_line(&vec![1], &vec![Unknown, Unknown]).unwrap(),
            [Unknown, Unknown]
        );
        assert_eq!(
            solve_line(&vec![2], &vec![Unknown, Unknown]).unwrap(),
            [Black, Black]
        );
        assert_eq!(
            solve_line(&vec![2], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Black, Unknown]
        );
        assert!(solve_line(&vec![2], &vec![Unknown, White, Unknown]).is_err());
        assert!(solve_line(&vec![20], &vec![Unknown, Unknown]).is_err());
    }

    #[test]
    fn solve_line_two() {
        assert!(solve_line(&vec![1, 1], &vec![Unknown, Unknown]).is_err());
        assert_eq!(
            solve_line(&vec![1, 1], &vec![Unknown, Unknown, Unknown]).unwrap(),
            [Black, White, Black]
        );
        assert_eq!(
            solve_line(&vec![1, 1], &vec![Unknown, Unknown, Unknown, Unknown]).unwrap(),
            [Unknown, Unknown, Unknown, Unknown]
        );
        assert_eq!(
            solve_line(&vec![1, 1], &vec![Unknown, Unknown, Black, Unknown]).unwrap(),
            [Black, White, Black, White]
        );
        assert_eq!(
            solve_line(&vec![1, 1], &vec![Unknown, Unknown, Black, Unknown, Black]).unwrap(),
            [White, White, Black, White, Black]
        );
    }
}

fn solve_inner(
    rows: Vec<Vec<usize>>,
    cols: Vec<Vec<usize>>,
    mut known_state: Vec<Vec<CellState>>,
) -> Result<Vec<Vec<CellState>>, BadSolveError> {
    // Deductive phase
    // While successfully solving
    // solve rows
    // solve columns
    let mut row_change = true;
    let mut col_change = true;
    while col_change {
        col_change = false;
        // solve each row
        for (hint, row_state) in rows.iter().zip(known_state.iter_mut()) {
            let new = solve_line(hint, row_state)?;
            if new != *row_state {
                row_change = true;
                *row_state = new;
            }
        }

        if row_change {
            row_change = false;
            known_state = transpose(known_state);
            // solve each col
            for (hint, col_state) in cols.iter().zip(known_state.iter_mut()) {
                let new = solve_line(hint, col_state)?;
                if new != *col_state {
                    col_change = true;
                    *col_state = new;
                }
            }
            known_state = transpose(known_state);
        }
    }

    // Check if fully solved, if so return.
    if !known_state
        .iter()
        .any(|row| row.iter().any(|el| *el == Unknown))
    {
        return Ok(known_state);
    }

    // Not possible to deduce further, need to use guessing algorithm below:
    // pick an unknown cell as white and solve_inner
    // if that works, return
    // if that doesn't work, try the alternative
    // if that works, return
    // if that doesn't work, abort

    // However, I am lazy, so return an incomplete state
    Ok(known_state)
}

fn solve(
    rows: Vec<Vec<usize>>,
    cols: Vec<Vec<usize>>,
) -> Result<Vec<Vec<CellState>>, BadSolveError> {
    // Build initial state
    let state = vec![vec![CellState::Unknown; cols.len()]; rows.len()];

    solve_inner(rows, cols, state)
}

fn prettify(state: &[Vec<CellState>]) -> String {
    fn get_char(el: &CellState) -> &'static str {
        match el {
            CellState::Black => "X",
            CellState::White => " ",
            CellState::Unknown => "?",
        }
    }
    return state
        .iter()
        .map(|row| row.iter().map(get_char).collect::<String>())
        .collect::<Vec<String>>()
        .join("\n");
}

fn main() {
    for _ in 0..1 {
        for file in [
            //"Examples/Easy1.txt",
            //"Examples/Easy2.txt",
            //"Examples/Medium1.txt",  // Medium 30x30
            "Examples/Medium2.txt",  // Medium 30x30
            //"Examples/XMLpuz24361.cgi.xml",  // Hard: 30x30
            //"Examples/XMLpuz22949.cgi.xml",  // Hard: 40x40
            //"Examples/XMLpuz25820.cgi.xml",  // Mega hard: 75:71
        ] {
            println!("Solving {}", file);
            let (rows, cols) = parse_file(file);
            //println!("{:?}", rows);
            //println!("{:?}", cols);
            let result = solve(rows, cols).unwrap();
            println!("{}", prettify(&result));
        }
    }
}
